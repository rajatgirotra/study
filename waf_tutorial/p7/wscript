# Read README.txt first. options context
def options(options_ctx):
    # the load function takes a list of waf tools to load
    options_ctx.load(['compiler_c', 'compiler_cxx'])


def configure(conf_ctx):
    # the load function takes a list of waf tools to load
    conf_ctx.load(['compiler_c', 'compiler_cxx'])


    # the following text is very important. If i see the official documentation of ConfigurationContext, there is no function check() defined in that class.
    # however check is defined in waflib.Tools.c_config.check(), but this function check() is bound to ConfigurationContext using decorator.
    # see a code snippet of the conf() defined in ConfigurationContext. So if you use @conf decorator to any function, it will be exposed as a member 
    # function of the ConfigurationContext class.
    # the documentation of this function check() is in c_config.
    # waflib.Tools.c_config.check(self, *k, **kw)[source]
    #     Configuration Method bound to waflib.Configure.ConfigurationContext
    # you will see this very often in waf
    conf.check(features='cxx cxxprogram', lib=['m'], cflags=['-Wall'], defines=['var=foo'], uselib_store='M') 
    # conf.check() runs the compiler internally to check if libm is available on the OS and also if cflags -Wall is accepted and defines -Dvar=foo
    # if check is successfull, creates
    # conf.env.LIB_M = ['m']
    # conf.env.CFLAGS_M = ['-Wall']
    # conf.env.DEFINES_M = ['var=foo'] 
    # otherwise raises ConfigurationError


    	







#def conf(f):
#        def fun(*k,**kw):
#               mandatory=kw.pop('mandatory',True)
#               try:
#                       return f(*k,**kw)
#                except Errors.ConfigurationError:
#                        if mandatory:
#                                raise
#        fun.__name__=f.__name__
#        setattr(ConfigurationContext,f.__name__,fun)
#        setattr(Build.BuildContext,f.__name__,fun)
#        return f
