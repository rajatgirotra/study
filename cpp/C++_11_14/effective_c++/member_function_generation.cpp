/*
in C++98, c'tor, d'tor, copy c'tor and copy assignment functions are synthesized by the compiler if not provided explicitly. In C++11 two new additions are the move c'tor and the move assignment operator. Just like copy ctor and copy assignment operators perform memberwise copy, move c'tor and move assignment operator perform memberwise moves. Ie. they use std::move() in each assignment. std::move() will give you an rvalue reference; however if the object being moved is not move-enabled (like some legacy C++98 code you have written), it will end up calling the corresponding copy c'tor or assignment. So we say that move c'tor and move assignment operators perform move requests, then depending overload resolution, the copy or move operation is performed.

What are the rules under which move operations are generated by the compiler?
Rule 1
------
1) CC and CA are independent. If you only define one, the compiler will generate the other if required.
2) MC and MA are not independent. If you define one, the other will not be generated. The rationale is that since the developer defines one explicitly, there must be something different about how it is implemented, so the compiler cannot generate the default version which does memberwise move.

Rule 2
------
If you declare either of the Copy operations, the move operators will not be generated. and vice versa. This is because the compiler again believes that since the user has manually provided the copy (or move) operation, this means there is something special about it, so the default move(copy) operation wont suffice any way.

Rule 3
------
C++98 has a rule of three. If you declare any of the CC, CA or DTOR, then you must declare all three. This is because for example, if you define your own CC, this means that there is some resource management that you are doing in your CC, so you should do that in the CA also and also the DTOR wont be trivial in that case. On the other hand, if you defined a DTOR this means that there was something special about the destruction and that the default CC and CA wont have sufficed so should not be generated in C++98. However this was overlooked and compilers were allowed to generate CC and CA. this continues to be the rule in C++11 otherwise too much legacy code would break. However this means that since we follow the rule of three in C++11 also, declaring a DTOR will require declaring CA and CC which disables generation of MC amd MA.

So Move operations are declared if:
1) There are no explicit copy operations declared
2) No explicit DTOR
3) No explicit Move opeartion declared.

C++11 however has deprecated generation of Copy operations to be implicitly declared for classes having a user defined DTOR. So you should go back and fix all your legacy code using:

Widget(const Widget&) = default;
Widget& operator=(const Widget&) = default;

*/

#include <iostream>
using namespace std;

