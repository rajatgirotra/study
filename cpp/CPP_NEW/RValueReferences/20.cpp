#include <iostream>
#include <string>
#include <type_traits>
using namespace std;


struct Person {
    std::string mName;

    // template constructor
    template <typename T>
    explicit Person(T&& arg) noexcept : mName(std::forward<T>(arg)) {
    }

    explicit Person(int index) {}

    // copy c'tor and other members generated automatically by the compiler
};

//struct SuperPerson : public Person {
//    // SuperPerson(const SuperPerson& sp) : Person(sp) {}
//};

int main() {
    std::string name("Rajat");
    Person p(name);
    // const Person p(name);
    cout << p.mName << endl;

    // simple copy construction doesnt work. Why?
    /*
     * The object cloneP is non-const. But the copy c'tor generated by the compiler is Person(const Person&);
     * so the compiler uses the forwarding contructor as it is a better match.
     *
     * Infact if you have an empty sub-class (SuperPerson) here; the sub class copy or move ctor calls the base class version,
     * even that prefers the forwarding contructor (not the base class copy and move ctor's), because the argument is of type SuperPerson not Person.
     */
    auto cloneP(p); // if you make p const, it should work.

}