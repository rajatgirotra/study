Serialization internals
=======================
Normally serialization and de-serialization are performed by separate java processes and may occur at different times. What would happen if the serialized type has changed
between serialization and de-serialization times? The answer is it depends.
Java explicitly tells you which are compatible and which are incompatible changes. incompatible changes will break the ability to de-serialize an object.

https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/version.html#compatible-changes
https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/version.html#incompatible-changes

Generally
1) Adding new fields to your class are compatible changes
2) Changing the type of primitive field is incompatible.
3) Deleting a field is incompatible.
4) changing the type of object can be compatible or incompatible.
   Example: changing
   "private List<String> weapons = new ArrayList<>();" to "private List<String> weapons = new LinkedList<>();" is compatible.
   Since the super types of ArrayList and LinkedList is same, the change is compatible.
you will find others as we start coding.

Also, java stores a special field called "serialVersionUID" in the serialized object. This field is a number which is automatically generated based on the
1) number of member fields in the object
2) the types of those fields.
3) any more I find out I will add here.

So de-serialization will compute the serialVersionUID on the fly and compare with the serialVersionUID in the serialized object and throw an exception if those are not same.
You can also provide your own "private static final long serialVersionUID = 1L;" member field to override the one generated by de-serialization API.
Let's test that first.

In SerializationTest.java, by default the DummyRecord class should have a String, an int, and a List<String> fields. Write a serialized object and then change the integer field to long;
and try to de-serialize again. You should see a serialVersionUID error (InvalidClassException).
java.io.InvalidClassException: org.input_output.DummyRecord; local class incompatible: stream classdesc serialVersionUID = -8547607849433182758, local class serialVersionUID = 8758973583672800101

You can now:
 1) add "private static final long serialVersionUID = 1L;" to DummyRecord
 2) change DummyRecord "score" field to int. write a serialized object to file.
 3) change DummyRecord "score" field to long. try to de-serialize.
 Basically we are trying to fool the API by telling it that nothing has changed and the serialVersionUID is still 1L.
 Did it work? No, it won't, even though you tried to fool the API. It still can see that the types int and long are really incompatible, so it still throws an InvalidClassException.
 java.io.InvalidClassException: org.input_output.DummyRecord; incompatible types for field score.

 Let's now introduce a new field of type Long called bigscore. (adding fields is a compatible change). and when the object is de-serialized and ctor runs, in that we can
 initialize "long bigscore" from the "int score" field.
 Did it work? No it won't. why? it's because the de-serialization code doesn't even call the constructor at all.

So how do we get bigscore to be set to the value of score field during de-serialization? the answer is we override the readObject function.
see readObject() in DummyRecord.java.

Transient fields
================
the transient modifier when applied to a field means the default serialization API will not persist it. Let's create a transient "accountId" field.
you can still override the writeObject() and serialize/de-serialize it.

serialization of static fields
==============================
you can serialize static fields by overriding the writeObject() function.

Caveat
======
Let say version 1 (i.e. the static int version field) of class has "int score"
and version 2 of the file has "long score". so in the readObject(), you can put an if condition to check if the version is 1 or 2 and either do readInt() or readLong().
However, the "score" field must be declared as transient for this to work. Without the use of transient, it will be treated as an incompatible change.